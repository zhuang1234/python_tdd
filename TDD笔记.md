
django 创建一个项目

"""

```
django-admin.py startproject superlists

 superlists
    ├── manage.py
    └── superlists
        ├── __init__.py
        ├── settings.py
        ├── urls.py
        └── wsgi.py

```

​	

geckodriver 是一原生态的第三方浏览器，对于selenium3.x版本都会使用geckodriver来驱动firefox，所以需要下载geckodriver
"""

(1) 先写功能测试 从用户的角度描述应用的新功能。

(2) 功能测试失败后想办法编写代码让它通过或者说至少让当前失败的测试通过。此时使用一个或多个单元测试 定义希望代码实现的效果保证为应用中的每一行代码至少编写一个单元测试。

(3) 单元测试失败后编写最少量的应用代码 刚好让单元测试通过。有时要在第 2 步和第 3 步之间多次往复直到我们觉得功能测试有一点进展为止。

(4) 然后再次运行功能测试看能否通过或者有没有进展。这一步可能促使我们编写一些新的单元测试和代码等。



**功能测试站在高层驱动开发而单元测试则从低层驱动我们做些什么**



Django 遵守了经典的模型 - 视图 - 控制器 Model-View-Controller MVC模式但并没严格遵守 。Django 确实有模型但视图更像是控制器模板其实才是视图。不过MVC 的思想还在。

Django 和任何一种 Web 服务器一样主要任务是决定用户访问网站中的某个 URL 时做些什么。Django 的工作流程有点儿类似下述过程。

(1) 针对某个 URL 的 HTTP 请求 进入。

(2) Django 使用一些规则决定由哪个视图 函数处理这个请求这一步叫作解析 URL。

(3) 选中的视图函数处理请求然后返回 HTTP 响应 。



因此要测试两件事。

能否解析网站根路径“/”的 URL将其对应到我们编写的某个视图函数上
能否让视图函数返回一些 HTML让功能测试通过



resolve 是 Django 内部使用的函数用于解析 URL并将其映射到相应的视图函数上。检查解析网站根路径“/”时是否能找到名为 home_page 的函数。



“单元测试/编写代码”循环

现在可以开始适应 TDD 中的单元测试 / 编写代码 循环了。

(1) 在终端里运行单元测试看它们是如何失败的。

(2) 在编辑器中改动最少量的代码让当前失败的测试通过。

然后不断重复。

想保证编写的代码无误每次改动的幅度就要尽量小。这么做才能确保每一部分代码都有对应的测试监护。

乍一看工作量很大初期也的确如此。但熟练之后你便会发现即使步伐迈得很小编程的速度也很快。我们在工作中就是这样编写实际代码的。



本章介绍了以下知识

新建 Django 应用。
Django 的单元测试运行程序。
功能测试和单元测试之间的区别。
Django 解析 URL 的方法urls.py 文件的作用。
Django 的视图函数请求和响应对象。
如何返回简单的 HTML

有用的命令和概念

启动Django 的开发服务器

python manage.py runserver


运行功能测试

python functional_tests.py


运行单元测试

python manage.py test


“单元测试/ 编写代码”循环

(1) 在终端里运行单元测试。
(2) 在编辑器中改动最少量的代码。
(3) 重复上两步。

编程其实很难我们的成功往往得益于自己的聪明才智。假如我们不那么聪明TDD 就能助我们一臂之力。Kent BeckTDD 理念基本上就是他发明的打了个比方。试想你用绳子从井里提一桶水如果井不太深而且桶不是很满提起来很容易。就算提满满一桶水刚开始也很容易。但要不了多久你就累了。TDD 理念好比是一个棘轮你可以使用它保存当前的进度休息一会儿而且能保证进度绝不倒退。这样你就没必要一直 那么聪明了如图 4-1。、

首先既然测试那么简单写起来就不会花很长时间。所以别抱怨了只管写就是了。
其次占位测试很重要。先为简单的函数写好测试当函数变复杂后这道心理障碍就容易迈过去。你可能会在函数中添加一个 if 语句几周后再添加一个 for 循环不知不觉间就将其变成一个基于元类meta-class的多态树状结构解析器了。因为从一开始你就编写了测试每次修改都会自然而然地添加新测试最终得到的是一个测试良好的函数。相反如果你试图判断函数什么时候才复杂到需要编写测试的话那就太主观了而且情况会变得更糟因为没有占位测试此时开始编写测试需要投入很多精力每次改动代码都冒着风险你开始拖延很快青蛙就煮熟了。
不要试图找一些不靠谱的主观规则去判断什么时候应该编写测试什么时候可以全身而退。我建议你现在遵守我制定的训练方法因为所有技能都一样只有花时间学会了规则才能打破规则。

TDD 的优点之一是永远不会忘记接下该做什么——重新运行测试就知道要做的事了

 Selenium 中 find_element_by... 和 find_elements_by... 这两类函数的区别。前者返回一个元素如果找不到就抛出异常后者返回一个列表这个列表可能为空。
还有留意一下 any 函数它是 Python 中的原生函数却鲜为人知。

any 函数的参数是个生成器表达式 generator expression类似于列表推导 list comprehension但比它更为出色。你需要仔细研究这个概念。你可以搜索 Guido 名为“From List Comprehensions to Generator Expressions”的文章。读完之后你就会知道这个函数可不仅仅是为了让编程惬意。

一般来说单元测试的规则之一是不测试常量

单元测试要测试的其实是逻辑、流程控制和配置。编写断言检测 HTML 字符串中是否有指定的字符序列不是单元测试应该做的。



render 函数。这个函数的第一个参数是请求对象原因稍后说明第二个参数是渲染的模板名



执行 startapp 命令以及在项目文件夹中存放一个应用还不够你要告诉 Django 确实 要开发一个应用并把这个应用添加到文件 settings.py 中。这么做才能保证万无一失。打开 settings.py找到变量 INSTALLED_APPS 把 lists 加进去

测试是否正确渲染模板的一种方法是在测试中手动渲染模板然后与视图返回的结果做比较。为此可以利用 Django 提供的 render_to_string 函数



Django 提供的测试客户端Test Client才是检查使用哪个模板的原生方式



TDD 的总体流程

首先编写一个测试运行这个测试看着它失败。然后编写最少量的代码取得一些进展再运行测试。如此不断重复直到测试通过为止。最后或许还要重构代码测试能确保不破坏任何功能。

如果既有功能测试又有单元测试该怎么运用这个流程呢你可以把功能测试当作循环的一种高层视角而“编写代码让功能测试通过”这一步则是另一个小型 TDD 循环这个小循环使用单元测试如图 4-4 所示。





CSRF（Cross-Site Request Forgery）：跨站请求伪造 

Django 针对 CSRF 的保护措施是在生成的每个表单中放置一个自动生成的令牌通过这个令牌判断 POST 请求是否来自同一个网站。之前的模板都是纯粹的 HTML在这里要首次体验 Django 模板的魔力使用模板标签 template tag添加 CSRF 令牌。模板标签的句法是花括号和百分号形式即 {% ... %} ——这种写法很有名要连续多次同时按两个键是世界上最麻烦的输入方式。

{{ ... }} 它会以字符串的形式显示对象

render 函数的第三个参数是一个字典把模板变量的名称映射在值上

查阅 dict.get 的文档

```
dict.get(key, default=None)
```

## 参数

- key -- 字典中要查找的键。
- default -- 如果指定键的值不存在时，返回该默认值。

“遇红 / 变绿 / 重构”和三角法
“单元测试 / 编写代码”循环有时也叫“遇红 / 变绿 / 重构 ”。

先写一个会失败的单元测试遇红 。
编写尽可能简单的代码让测试通过变绿 就算作弊也行 。
重构 改进代码让其更合理。
那么在重构阶段应该做些什么呢如何判断什么时候应该把作弊的代码改成令我们满意的实现方式呢
一种方法是消除重复 如果测试中使用了神奇常量例如列表项目前面的“1:”而且应用代码中也用了这个常量这就算是重复此时就应该重构。把神奇常量从应用代码中删掉往往意味着你不能再作弊了。
我觉得这种方法有点不太明确所以经常使用第二种方法这种方法叫作“三角法 ”如果编写无法让你满意的作弊代码例如返回一个神奇的常量就能让测试通过就再写一个测试 强制自己编写更好的代码。现在就要使用这种方法扩充功能测试检查输入的第二个 列表项目中是否包含“2:”。



在继续之前先看一下功能测试中的代码异味 。1 检查清单表格中新添加的待办事项时用了三个几乎一样的代码块。编程中有个原则叫作不要自我重复 Don't Repeat YourselfDRY按照真言“事不过三三则重构 ”的说法运用这个原则。复制粘贴一次可能还不用删除重复但如果复制粘贴了三次就该删除重复了。



数据库中创建新记录的过程很简单先创建一个对象再为一些属性赋值然后调用 .save() 函数。Django 提供了一个查询数据库的 API即类属性 .objects 。再使用可能是最简单的查询方法 .all() 取回这个表中的全部记录。得到的结果是一个类似列表的对象叫 QuerySet 。从这个对象中可以提取出单个对象然后还可以再调用其他函数例如 .count() 。接着检查存储在数据库中的对象看保存的信息是否正确。

在 Django 中ORM 的任务是模型化数据库。创建数据库其实是由另一个系统负责的叫作迁移 migration。迁移的任务是根据你对 models.py 文件的改动情况添加或删除表和列。

你可以把迁移想象成数据库使用的版本控制系统。后面会看到把应用部署到线上服务器升级数据库时迁移十分有用

python manage.py makemigrations

在数据库中添加了一个新字段所以要再创建一个迁移

在 models.py 中添加了两行新代码创建了两个数据库迁移由此得到的结果是模型对象上的 .text 属性能被识别为一个特殊属性了因此属性的值能保存到数据库中测试也能通过了

视图函数有两个作用 一是处理用户输入  二是返回适当的响应。
处理完 POST 请求后一定要重定向

良好的单元测试实践方法要求一个测试只能测试一件事。因为这样便于查找问题。如果一个测试中有多个断言一旦前面的断言导致测试失败就无法得知后面的断言情况如何

Django 的模板句法中有一个用于遍历列表的标签即 {% for .. in .. %}

 Django 为单元测试创建了专用的测试数据库 ——这是 Django 中 TestCase 所做的神奇事情之一。
 python manage.py migrate

Django模板
 forloop.counter

python manage.py migrate --noinput

有用的 TDD 概念
 
回归
    新添加的代码破坏了应用原本可以正常使用的功能。
意外失败
    测试在意料之外失败了。这意味着测试中有错误或者测试帮我们发现了一个回归因此要在代码中修正。
遇红 / 变绿 / 重构 描述TDD 流程的另一种方式。先编写一个测试看着它失败遇红然后编写代码让测试通过变绿最后重构改进实现方式。
三角法
    添加一个测试专门为某些现有的代码编写用例以此推断出普适的实现方式在此之前的实现方式可能作弊了。
事不过三三则重构
    判断何时删除重复代码时使用的经验法则。如果两段代码很相似往往还要等到第三段相似代码出现才能确定重构时哪一部分是真正共通、可重用的。
记在便签上的待办事项清单
    在便签上记录编写代码过程中遇到的问题等手头的工作完成后再回过头来解决。

 1.4 版开始Django 提供的一个新类 LiveServerTestCase 可以代我们完成这一任务。这个类会自动创建一个测试数据库跟单元测试一样并启动一个开发服务器让功能测试在其中运行。虽然这个工具有一定局限性

 从 Django 1.6 开始测试运行程序查找所有名字以 test 开头的文件。为了保持文件结构清晰要新建一个文件夹保存功能测试让它看起来就像一个应用。Django 对这个文件夹的要求只有一个——必须是有效的 Python 模块即文件夹中要有一个 __init__.py 文件。

 使用 git mv 命令完成这个操作让 Git 知道文件移动了

python manage.py test functional_tests

git diff 命令中的 -M 标志很有用意思是“检测移动”所以 git 会注意到 functional_tests.py 和 functional_tests/tests.py 是同一个文件显示更合理的差异去掉这个旗标试试。

“隐式等待”某些情况下当 Selenium 认为页面正在加载时它会“自动”等待一会儿。
隐式等待有点奇怪而且从 Selenium 3 开始隐式等待变得极度不可靠。此外Selenium 团队普遍认为隐式等待不是个好主意应该避免使用

两种异常一种是 WebDriverException 在页面未加载或 Selenium 未在页面上找到表格元素时抛出另一种是 AssertionError 因为页面中虽有表格但它可能在页面重新加载之前就存在里面还是没有我们要找的行。


本章运用的测试“最佳实践”
 
确保测试隔离管理全局状态
不同的测试之间不能彼此影响也就是说每次测试结束后都要还原永久状态。Django 的测试运行程序可以帮助我们创建测试数据库这个数据库在每次测试结束后都会清空详情请参见第 23 章。
避免使用“含糊的”休眠
一旦需要等待什么加载我们的第一反应便是使用 time.sleep 。但是这样做带来的问题是时间的长度是两眼一抹黑要么太短容易导致假失败要么太长会拖慢测试。我推荐使用重试循环它可以轮询应用尽早向前行进。
不要依赖Selenium的隐式等待
Selenium 确实有理论上的“隐式”等待但是在不同浏览器上的实现各不相同。而且在写作本书时隐式等待在 Selenium 3 的 Firefox 驱动上极度不可靠。Python 之禅说道“明了胜于晦涩”因此首选显式等待。

7.1.1　不要预先做大量设计

TDD 和软件开发中的敏捷运动联系紧密。敏捷运动反对传统软件工程实践中预先做大量设计 的做法因为除了要花费大量时间收集需求之外设计阶段还要用等量的时间在纸上规划软件。敏捷理念则认为在实践中解决问题比理论分析能学到更多而且让应用尽早接受真实用户的检验效果更好。无须花这么多时间提前设计而要尽早把最简可用的应用 放出来根据实际使用中得到的反馈逐步向前推进设计。

这并不是说要完全禁止思考设计。前一章我们看到不经思考呆头呆脑往前走最终也能找到正确答案不过稍微思考一下设计往往能帮助我们更快地找到答案。那么下面分析一下这个最简可用的应用想想应该使用哪种设计方式。

 
想让每个用户都能保存自己的清单目前来说至少能保存一个清单。
清单由多个待办事项组成待办事项的主要属性应该是一些描述性文字。
要保存清单以便多次访问。现在可以为用户提供一个唯一的 URL指向他们的清单。以后或许需要一种自动识别用户的机制然后把他们的清单显示出来。
为了实现第一条看样子要把清单和其中的待办事项存入数据库。每个清单都有一个唯一的 URL而且清单中的每个待办事项都是一些描述性文字和所在的清单关联。

7.1.2　YAGNI

关于设计的思考一旦开始就很难停下来我们会冒出各种想法或许想给每个清单起个名字或加个标题或许想使用用户名和密码识别用户或许想给清单添加一个较长的备注和简短的描述或许想存储某种顺序等等。但是要遵守敏捷理念的另一个信条“YAGNI”读作 yag-knee。它是“You ain't gonna need it”你不需要这个的简称。作为软件开发者我们从创造事物中获得乐趣。有时我们冒出一个想法觉得可能 需要便无法抵御内心的冲动想要开发出来。可问题是不管想法有多好大多数情况下最终你都用不到 这个功能。应用中会残留很多没用的代码还增加了应用的复杂度。YAGNI 是个真言可以用来抵御热切的创造欲


“表现层状态转化”representational state transferREST是 Web 设计的一种方式经常用来引导基于 Web 的 API 设计。设计面向用户的网站时不必严格 遵守 REST 规则可是从中能得到一些启发。如果想看看真实的 REST API 是什么样子可以跳到附录 F。

REST 建议 URL 结构匹配数据结构即这个应用中的清单和其中的待办事项。清单有各自的 URL

 assertRegex 是 unittest 提供的辅助函数用于检查字符串是否匹配正则表达式。我们利用它检查新的 REST 式设计能否实现。详情请参见 unittest 的文档。

 根据经验第二个线索是当所有单元测试都能通过而功能测试不能通过时问题通常是由单元测试没有覆盖的事物引起的——这往往是模板的问题。

